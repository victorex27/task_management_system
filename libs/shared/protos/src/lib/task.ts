// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.1
//   protoc               v3.19.1
// source: task.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

export const protobufPackage = "task";

export interface Query {
  page?: number | undefined;
  limit?: number | undefined;
}

export interface QueryData {
  status?: string | undefined;
  priority?: string | undefined;
  assignedTo?: string | undefined;
}

export interface GetTasksRequest {
  data?: QueryData | undefined;
  query?: Query | undefined;
}

export interface GetTasksData {
  total: number;
  tasks: Task[];
}

export interface GetTasksResponse {
  status: number;
  success: boolean;
  message: string;
  error?: string | undefined;
  data: GetTasksData | undefined;
}

export interface GetTaskRequest {
  id: string;
  isDeleted?: boolean | undefined;
}

export interface GetTaskResponse {
  status: number;
  success: boolean;
  message: string;
  error?: string | undefined;
  data: Task | undefined;
}

export interface Task {
  id: string;
  title: string;
  description: string;
  assignedTo: string;
  createdBy: string;
  status: string;
  priority: string;
  dueDate?: string | undefined;
  completedAt?: string | undefined;
  createdAt?: string | undefined;
  updatedAt?: string | undefined;
  isDeleted?: boolean | undefined;
}

export interface CreateTaskRequest {
  title: string;
  description: string;
  assignedTo: string;
  createdBy: string;
  status: string;
  priority: string;
  dueDate?: number | undefined;
  completedAt?: number | undefined;
}

export interface CreateTaskResponse {
  status: number;
  success: boolean;
  message: string;
  error?: string | undefined;
  data: Task | undefined;
}

export interface UpdateTaskRequest {
  id?: string | undefined;
  status?: string | undefined;
  priority?: string | undefined;
  dueDate?: number | undefined;
  completedAt?: number | undefined;
  isDeleted?: boolean | undefined;
}

export interface UpdateTaskResponse {
  status: number;
  success: boolean;
  message: string;
  error?: string | undefined;
  data: Task | undefined;
}

export const TASK_PACKAGE_NAME = "task";

function createBaseQuery(): Query {
  return {};
}

export const Query: MessageFns<Query> = {
  encode(message: Query, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== undefined) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Query {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseQueryData(): QueryData {
  return {};
}

export const QueryData: MessageFns<QueryData> = {
  encode(message: QueryData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      writer.uint32(10).string(message.status);
    }
    if (message.priority !== undefined) {
      writer.uint32(18).string(message.priority);
    }
    if (message.assignedTo !== undefined) {
      writer.uint32(26).string(message.assignedTo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.priority = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assignedTo = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetTasksRequest(): GetTasksRequest {
  return {};
}

export const GetTasksRequest: MessageFns<GetTasksRequest> = {
  encode(message: GetTasksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      QueryData.encode(message.data, writer.uint32(10).fork()).join();
    }
    if (message.query !== undefined) {
      Query.encode(message.query, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTasksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTasksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = QueryData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.query = Query.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetTasksData(): GetTasksData {
  return { total: 0, tasks: [] };
}

export const GetTasksData: MessageFns<GetTasksData> = {
  encode(message: GetTasksData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.total !== 0) {
      writer.uint32(8).int32(message.total);
    }
    for (const v of message.tasks) {
      Task.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTasksData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTasksData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tasks.push(Task.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetTasksResponse(): GetTasksResponse {
  return { status: 0, success: false, message: "", data: undefined };
}

export const GetTasksResponse: MessageFns<GetTasksResponse> = {
  encode(message: GetTasksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.error !== undefined) {
      writer.uint32(34).string(message.error);
    }
    if (message.data !== undefined) {
      GetTasksData.encode(message.data, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTasksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTasksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.data = GetTasksData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetTaskRequest(): GetTaskRequest {
  return { id: "" };
}

export const GetTaskRequest: MessageFns<GetTaskRequest> = {
  encode(message: GetTaskRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.isDeleted !== undefined) {
      writer.uint32(16).bool(message.isDeleted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTaskRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isDeleted = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetTaskResponse(): GetTaskResponse {
  return { status: 0, success: false, message: "", data: undefined };
}

export const GetTaskResponse: MessageFns<GetTaskResponse> = {
  encode(message: GetTaskResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.error !== undefined) {
      writer.uint32(34).string(message.error);
    }
    if (message.data !== undefined) {
      Task.encode(message.data, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTaskResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTaskResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.data = Task.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTask(): Task {
  return { id: "", title: "", description: "", assignedTo: "", createdBy: "", status: "", priority: "" };
}

export const Task: MessageFns<Task> = {
  encode(message: Task, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.assignedTo !== "") {
      writer.uint32(34).string(message.assignedTo);
    }
    if (message.createdBy !== "") {
      writer.uint32(42).string(message.createdBy);
    }
    if (message.status !== "") {
      writer.uint32(50).string(message.status);
    }
    if (message.priority !== "") {
      writer.uint32(58).string(message.priority);
    }
    if (message.dueDate !== undefined) {
      writer.uint32(66).string(message.dueDate);
    }
    if (message.completedAt !== undefined) {
      writer.uint32(74).string(message.completedAt);
    }
    if (message.createdAt !== undefined) {
      writer.uint32(82).string(message.createdAt);
    }
    if (message.updatedAt !== undefined) {
      writer.uint32(90).string(message.updatedAt);
    }
    if (message.isDeleted !== undefined) {
      writer.uint32(96).bool(message.isDeleted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Task {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.assignedTo = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdBy = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.priority = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.dueDate = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.completedAt = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.isDeleted = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateTaskRequest(): CreateTaskRequest {
  return { title: "", description: "", assignedTo: "", createdBy: "", status: "", priority: "" };
}

export const CreateTaskRequest: MessageFns<CreateTaskRequest> = {
  encode(message: CreateTaskRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.assignedTo !== "") {
      writer.uint32(26).string(message.assignedTo);
    }
    if (message.createdBy !== "") {
      writer.uint32(34).string(message.createdBy);
    }
    if (message.status !== "") {
      writer.uint32(42).string(message.status);
    }
    if (message.priority !== "") {
      writer.uint32(50).string(message.priority);
    }
    if (message.dueDate !== undefined) {
      writer.uint32(56).int64(message.dueDate);
    }
    if (message.completedAt !== undefined) {
      writer.uint32(64).int64(message.completedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTaskRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assignedTo = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdBy = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.priority = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.dueDate = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.completedAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateTaskResponse(): CreateTaskResponse {
  return { status: 0, success: false, message: "", data: undefined };
}

export const CreateTaskResponse: MessageFns<CreateTaskResponse> = {
  encode(message: CreateTaskResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.error !== undefined) {
      writer.uint32(34).string(message.error);
    }
    if (message.data !== undefined) {
      Task.encode(message.data, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTaskResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTaskResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.data = Task.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateTaskRequest(): UpdateTaskRequest {
  return {};
}

export const UpdateTaskRequest: MessageFns<UpdateTaskRequest> = {
  encode(message: UpdateTaskRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== undefined) {
      writer.uint32(18).string(message.status);
    }
    if (message.priority !== undefined) {
      writer.uint32(26).string(message.priority);
    }
    if (message.dueDate !== undefined) {
      writer.uint32(32).int64(message.dueDate);
    }
    if (message.completedAt !== undefined) {
      writer.uint32(40).int64(message.completedAt);
    }
    if (message.isDeleted !== undefined) {
      writer.uint32(48).bool(message.isDeleted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTaskRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.priority = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.dueDate = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.completedAt = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isDeleted = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateTaskResponse(): UpdateTaskResponse {
  return { status: 0, success: false, message: "", data: undefined };
}

export const UpdateTaskResponse: MessageFns<UpdateTaskResponse> = {
  encode(message: UpdateTaskResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.error !== undefined) {
      writer.uint32(34).string(message.error);
    }
    if (message.data !== undefined) {
      Task.encode(message.data, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTaskResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTaskResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.data = Task.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface TaskServiceClient {
  createTask(request: CreateTaskRequest): Observable<CreateTaskResponse>;

  updateTask(request: UpdateTaskRequest): Observable<UpdateTaskResponse>;

  getTasks(request: GetTasksRequest): Observable<GetTasksResponse>;

  getTask(request: GetTaskRequest): Observable<GetTaskResponse>;
}

export interface TaskServiceController {
  createTask(
    request: CreateTaskRequest,
  ): Promise<CreateTaskResponse> | Observable<CreateTaskResponse> | CreateTaskResponse;

  updateTask(
    request: UpdateTaskRequest,
  ): Promise<UpdateTaskResponse> | Observable<UpdateTaskResponse> | UpdateTaskResponse;

  getTasks(request: GetTasksRequest): Promise<GetTasksResponse> | Observable<GetTasksResponse> | GetTasksResponse;

  getTask(request: GetTaskRequest): Promise<GetTaskResponse> | Observable<GetTaskResponse> | GetTaskResponse;
}

export function TaskServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["createTask", "updateTask", "getTasks", "getTask"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("TaskService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("TaskService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const TASK_SERVICE_NAME = "TaskService";

export type TaskServiceService = typeof TaskServiceService;
export const TaskServiceService = {
  createTask: {
    path: "/task.TaskService/CreateTask",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateTaskRequest) => Buffer.from(CreateTaskRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateTaskRequest.decode(value),
    responseSerialize: (value: CreateTaskResponse) => Buffer.from(CreateTaskResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateTaskResponse.decode(value),
  },
  updateTask: {
    path: "/task.TaskService/UpdateTask",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateTaskRequest) => Buffer.from(UpdateTaskRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateTaskRequest.decode(value),
    responseSerialize: (value: UpdateTaskResponse) => Buffer.from(UpdateTaskResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateTaskResponse.decode(value),
  },
  getTasks: {
    path: "/task.TaskService/GetTasks",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTasksRequest) => Buffer.from(GetTasksRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetTasksRequest.decode(value),
    responseSerialize: (value: GetTasksResponse) => Buffer.from(GetTasksResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetTasksResponse.decode(value),
  },
  getTask: {
    path: "/task.TaskService/GetTask",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTaskRequest) => Buffer.from(GetTaskRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetTaskRequest.decode(value),
    responseSerialize: (value: GetTaskResponse) => Buffer.from(GetTaskResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetTaskResponse.decode(value),
  },
} as const;

export interface TaskServiceServer extends UntypedServiceImplementation {
  createTask: handleUnaryCall<CreateTaskRequest, CreateTaskResponse>;
  updateTask: handleUnaryCall<UpdateTaskRequest, UpdateTaskResponse>;
  getTasks: handleUnaryCall<GetTasksRequest, GetTasksResponse>;
  getTask: handleUnaryCall<GetTaskRequest, GetTaskResponse>;
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
